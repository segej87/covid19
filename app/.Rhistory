} else if (type == 'Acceleration') {
metric = paste0(metric, '_accel')
y_title = 'Rate Change'
legend.position = 'right'
} else {
y_title = 'Total'
legend.position = 'none'
}
plot_dat <- suppressWarnings(
map_data %>%
rename_at(metric, function(vars) 'metric') %>%
filter(Country.Region %in% countries,
Province.State %in% state_province,
metric > total_limit) %>%
if(type != 'Count') filter(., date_lag == 1) else .
)
metric
metric <- 'Confirmed_rate'
metric <- 'Confirmed'
type = 'rate'
type = 'Rate'
if (type == 'Rate') {
metric = paste0(metric, '_rate')
y_title = 'New'
legend.position = 'right'
} else if (type == 'Acceleration') {
metric = paste0(metric, '_accel')
y_title = 'Rate Change'
legend.position = 'right'
} else {
y_title = 'Total'
legend.position = 'none'
}
plot_dat <- suppressWarnings(
map_data %>%
rename_at(metric, function(vars) 'metric') %>%
filter(Country.Region %in% countries,
Province.State %in% state_province,
metric > total_limit) %>%
if(type != 'Count') filter(., date_lag == 1) else .
)
hovertemplate <- paste0(
'<b>Country/Province:</b> %{Country.Region}',
'<br><b>State/Province:</b> %{Province.State}',
'<br><b>Confirmed:</b> %{Confirmed}'
)
xlim <- st_bbox(plot_dat)[c('xmin', 'xmax')]
ylim <- st_bbox(plot_dat)[c('ymin', 'ymax')]
map <- ggplot() +
geom_sf(data = world_base,
fill = '#2b3e50',
colour = 'white',
lwd = 0.2) +
geom_sf(data = plot_dat,
mapping = aes_string(size = 'metric',
colour = 'metric',
text = 'CombinedLocation'),
fill = 'none',
alpha = 0.75) +
coord_sf(xlim = xlim, ylim = ylim) +
scale_colour_distiller(palette = 'Spectral') +
theme(panel.background = element_rect(fill = '#2b3e50'),
plot.background = element_rect(fill = '#2b3e50'),
strip.background = element_blank(),
axis.line.y = element_line(color = 'white'),
axis.line.x = element_blank(),
axis.ticks.x = element_blank(),
axis.text = element_text(color = 'white'),
axis.title = element_text(color = 'white', face = 'bold'),
panel.grid.major = element_blank(),
title = element_text(color = 'white', face = 'bold'),
legend.position = 'none',
legend.title = element_blank(),
legend.text = element_text(color = 'white', face = 'bold'),
legend.background = element_rect(fill = '#2b3e50'))
ggplotly(map, tooltip = append('size', 'CombinedLocation'))
head(plot_dat)
runApp('Documents/Covid19/app')
runApp('Documents/Covid19/app')
assign(
'map_data',
dat %>%
mutate(ind = apply(dat, MARGIN = 1, FUN = function(x) {paste(x[c('Latitude', 'Longitude')], collapse = '.')})) %>%
filter(!(Latitude == 0 & Longitude == 0),
!(is.na(Latitude) | is.na(Longitude))) %>%
st_as_sf(coords = c('Longitude', 'Latitude'), crs = st_crs(world_base)) %>%
mutate(CombinedLocation = ifelse(is.na(Admin2), as.character(Location), paste(Admin2, Location, sep = ', '))) %>%
group_by(Country.Region, CombinedLocation)  %>%
mutate(Confirmed_rate = Confirmed - lag(Confirmed, default = 0),
Deaths_rate = Deaths - lag(Deaths, default = 0),
Recovered_rate = Recovered - lag(Recovered, default = 0),
Confirmed_accel = Confirmed_rate - lag(Confirmed_rate, default = 0),
Deaths_accel = Deaths_rate - lag(Deaths_rate, default = 0),
Recovered_accel = Recovered_rate - lag(Recovered_rate, default = 0)) %>%
# left_join(populations, by = c('Country.Region', 'Province.State')) %>%
filter(Date == max(Date, na.rm = TRUE)) %>%
mutate(Location_name = ifelse(Location == 'None', as.character(Country.Region), as.character(Location))),
envir = .GlobalEnv
)
shiny::runApp('Documents/Covid19/app')
library(tidyverse)
library(broom)
source('load_data.R')
load('~/Documents/Covid19/app/data/parabolic_models_4_4_2020.R')
load('~/Documents/Covid19/app/data/parabolic_models_4_4_2020.RData')
country_predictions
predicted_totals
prediction_curves
setwd('~/Documents/Covid19/app')
library(yaml)
cfg <- yaml::read_yaml('cfg.yml')
packages <- append(unlist(cfg['packages']), 'broom')
for (p in packages) library(p, character.only = TRUE, quietly = TRUE, verbose = FALSE)
source('load_data.R')
model_dat <- country_grouped %>%
mutate(Confirmed2 = Confirmed^2) %>%
as.data.table()
model_dat$Country.Region <- replace(model_dat$Country.Region, model_dat$Country.Region == 'Korea, South', 'South Korea')
models <- model_dat %>%
group_by(Country.Region) %>%
do(Country.Fit = lm(formula = Confirmed_rate ~ Confirmed + I(Confirmed^2), data = .))
model.coeffs = tidy(models, Country.Fit)
signif_models <- (model.coeffs %>%
group_by(Country.Region) %>%
summarise(avgP = median(p.value)) %>%
filter(avgP <= 1e-6) %>%
select(Country.Region) %>%
as.data.frame())$Country.Region
if (!('South Korea' %in% signif_models)) signif_models <- append(signif_models, 'South Korea')
signif_data <- model_dat %>%
filter(Country.Region %in% signif_models)
country_predictions <- tibble()
for (c in signif_models) {
subset <- model_dat %>%
filter(Country.Region == c)
country.mod <- lm(formula = Confirmed_rate ~ Confirmed + I(Confirmed^2), data = subset)
assign(paste0('model.', c), country.mod)
subset$Predicted <- predict(object = country.mod, newdata = subset)
country_predictions <- country_predictions %>%
bind_rows(subset)
}
get_x_intercepts <- function(coefs) {
a <- coefs['I(Confirmed^2)']
b <- coefs['Confirmed']
c <- coefs['(Intercept)']
x = c((-b + sqrt(b^2 - 4 * a * c))/(2 * a),
(-b - sqrt(b^2 - 4 * a * c))/(2 * a))
return(x)
}
num_in_km <- function(num) {
if (num > 1000000) out <- paste(round(num/1000000), 'M') else if (num > 1000) out <- paste(round(num/1000), 'K') else out <- round(num)
return(out)
}
# Country Data ------------------------------------------------------------
countries <- c()
predict_starts <- c()
predict_ends <- c()
prediction_curves <- data.frame()
for (country in unique(country_predictions$Country.Region)) {
coefs <- coef(get(paste0('model.', country)))
tryCatch({
intercepts <- get_x_intercepts(coefs)
}, warning = function(w) {
cat(c)
intercepts <- get_x_intercepts(coefs)
})
countries <- append(countries, country)
predict_starts <- append(predict_starts, intercepts[1])
predict_ends <- append(predict_ends, intercepts[2])
prediction_x <- seq(intercepts[1], intercepts[2], length.out = 100)
prediction_y <- coefs['(Intercept)'] + coefs['Confirmed'] * prediction_x + coefs['I(Confirmed^2)'] * (prediction_x^2)
curve_data <- data.frame(Country.Region = country, Confirmed = prediction_x, Confirmed_rate = prediction_y)
prediction_curves %>%
bind_rows(curve_data) -> prediction_curves
}
predicted_totals <- data.frame(Country.Region = countries,
Predicted.Start = predict_starts,
Predicted.End = predict_ends)
head(signif_models)
head(model.coeffs)
save(model.coeffs, country_predictions, prediction_curves, predicted_totals, file = 'data/parabolic_models_4_4_2020.RData')
load('data/parabolic_models_4_4_2020.RData')
model.coeffs
library(yaml)
cfg <- yaml::read_yaml('cfg.yml')
packages <- append(unlist(cfg['packages']), 'broom')
for (p in packages) library(p, character.only = TRUE, quietly = TRUE, verbose = FALSE)
source('load_data.R')
model_dat <- country_grouped %>%
mutate(Confirmed2 = Confirmed^2) %>%
as.data.table()
model_dat$Country.Region <- replace(model_dat$Country.Region, model_dat$Country.Region == 'Korea, South', 'South Korea')
models <- model_dat %>%
group_by(Country.Region) %>%
do(Country.Fit = lm(formula = Confirmed_rate ~ Confirmed + I(Confirmed^2), data = .))
model.coeffs = tidy(models, Country.Fit)
signif_models <- (model.coeffs %>%
group_by(Country.Region) %>%
summarise(avgP = median(p.value)) %>%
filter(avgP <= 1e-6) %>%
select(Country.Region) %>%
as.data.frame())$Country.Region
if (!('South Korea' %in% signif_models)) signif_models <- append(signif_models, 'South Korea')
signif_data <- model_dat %>%
filter(Country.Region %in% signif_models)
country_predictions <- tibble()
for (c in signif_models) {
subset <- model_dat %>%
filter(Country.Region == c)
country.mod <- lm(formula = Confirmed_rate ~ Confirmed + I(Confirmed^2), data = subset)
assign(paste0('model.', c), country.mod)
subset$Predicted <- predict(object = country.mod, newdata = subset)
country_predictions <- country_predictions %>%
bind_rows(subset)
}
get_x_intercepts <- function(coefs) {
a <- coefs['I(Confirmed^2)']
b <- coefs['Confirmed']
c <- coefs['(Intercept)']
x = c((-b + sqrt(b^2 - 4 * a * c))/(2 * a),
(-b - sqrt(b^2 - 4 * a * c))/(2 * a))
return(x)
}
num_in_km <- function(num) {
if (num > 1000000) out <- paste(round(num/1000000), 'M') else if (num > 1000) out <- paste(round(num/1000), 'K') else out <- round(num)
return(out)
}
# Country Data ------------------------------------------------------------
countries <- c()
predict_starts <- c()
predict_ends <- c()
prediction_curves <- data.frame()
for (country in unique(country_predictions$Country.Region)) {
coefs <- coef(get(paste0('model.', country)))
tryCatch({
intercepts <- get_x_intercepts(coefs)
}, warning = function(w) {
cat(c)
intercepts <- get_x_intercepts(coefs)
})
countries <- append(countries, country)
predict_starts <- append(predict_starts, intercepts[1])
predict_ends <- append(predict_ends, intercepts[2])
prediction_x <- seq(intercepts[1], intercepts[2], length.out = 100)
prediction_y <- coefs['(Intercept)'] + coefs['Confirmed'] * prediction_x + coefs['I(Confirmed^2)'] * (prediction_x^2)
curve_data <- data.frame(Country.Region = country, Confirmed = prediction_x, Confirmed_rate = prediction_y)
prediction_curves %>%
bind_rows(curve_data) -> prediction_curves
}
predicted_totals <- data.frame(Country.Region = countries,
Predicted.Start = predict_starts,
Predicted.End = predict_ends)
unique(model_dat$Country.Region)
sorted(unique(model_dat$Country.Region))
order(unique(model_dat$Country.Region))
unique(model_dat$Country.Region)[order(unique(model_dat$Country.Region))]
model_dat$Country.Region <- replace(model_dat$Country.Region, model_dat$Country.Region == 'United Kingdom', 'UK')
unique(model_dat$Country.Region)[order(unique(model_dat$Country.Region))]
model_dat$Country.Region <- replace(model_dat$Country.Region, model_dat$Country.Region == 'Iran (Islamic Republic of)', 'Iran')
unique(model_dat$Country.Region)[order(unique(model_dat$Country.Region))]
library(yaml)
cfg <- yaml::read_yaml('cfg.yml')
packages <- append(unlist(cfg['packages']), 'broom')
for (p in packages) library(p, character.only = TRUE, quietly = TRUE, verbose = FALSE)
source('load_data.R')
model_dat <- country_grouped %>%
mutate(Confirmed2 = Confirmed^2) %>%
as.data.table()
model_dat$Country.Region <- replace(model_dat$Country.Region, model_dat$Country.Region == 'Korea, South', 'South Korea')
model_dat$Country.Region <- replace(model_dat$Country.Region, model_dat$Country.Region == 'United Kingdom', 'UK')
model_dat$Country.Region <- replace(model_dat$Country.Region, model_dat$Country.Region == 'Iran (Islamic Republic of)', 'Iran')
models <- model_dat %>%
group_by(Country.Region) %>%
do(Country.Fit = lm(formula = Confirmed_rate ~ Confirmed + I(Confirmed^2), data = .))
model.coeffs = tidy(models, Country.Fit)
signif_models <- (model.coeffs %>%
group_by(Country.Region) %>%
summarise(avgP = median(p.value)) %>%
filter(avgP <= 1e-6) %>%
select(Country.Region) %>%
as.data.frame())$Country.Region
if (!('South Korea' %in% signif_models)) signif_models <- append(signif_models, 'South Korea')
signif_data <- model_dat %>%
filter(Country.Region %in% signif_models)
country_predictions <- tibble()
for (c in signif_models) {
subset <- model_dat %>%
filter(Country.Region == c)
country.mod <- lm(formula = Confirmed_rate ~ Confirmed + I(Confirmed^2), data = subset)
assign(paste0('model.', c), country.mod)
subset$Predicted <- predict(object = country.mod, newdata = subset)
country_predictions <- country_predictions %>%
bind_rows(subset)
}
get_x_intercepts <- function(coefs) {
a <- coefs['I(Confirmed^2)']
b <- coefs['Confirmed']
c <- coefs['(Intercept)']
x = c((-b + sqrt(b^2 - 4 * a * c))/(2 * a),
(-b - sqrt(b^2 - 4 * a * c))/(2 * a))
return(x)
}
num_in_km <- function(num) {
if (num > 1000000) out <- paste(round(num/1000000), 'M') else if (num > 1000) out <- paste(round(num/1000), 'K') else out <- round(num)
return(out)
}
# Country Data ------------------------------------------------------------
countries <- c()
predict_starts <- c()
predict_ends <- c()
prediction_curves <- data.frame()
for (country in unique(country_predictions$Country.Region)) {
coefs <- coef(get(paste0('model.', country)))
tryCatch({
intercepts <- get_x_intercepts(coefs)
}, warning = function(w) {
cat(c)
intercepts <- get_x_intercepts(coefs)
})
countries <- append(countries, country)
predict_starts <- append(predict_starts, intercepts[1])
predict_ends <- append(predict_ends, intercepts[2])
prediction_x <- seq(intercepts[1], intercepts[2], length.out = 100)
prediction_y <- coefs['(Intercept)'] + coefs['Confirmed'] * prediction_x + coefs['I(Confirmed^2)'] * (prediction_x^2)
curve_data <- data.frame(Country.Region = country, Confirmed = prediction_x, Confirmed_rate = prediction_y)
prediction_curves %>%
bind_rows(curve_data) -> prediction_curves
}
predicted_totals <- data.frame(Country.Region = countries,
Predicted.Start = predict_starts,
Predicted.End = predict_ends)
# Plot the data
g <- ggplot(data = prediction_curves,
mapping = aes(x = Confirmed, y = Confirmed_rate, colour = Country.Region, fill = Country.Region)) +
labs(title = 'Case Trajectories',
subtitle = 'With Fitted Parabolic Models',
x = 'Total Cases',
y = 'Daily New Case Rate') +
geom_line() +
geom_point(data = country_predictions) +
geom_text_repel(data = predicted_totals, mapping = aes(x = predict_ends,
label = paste(Country.Region, sapply(predict_ends, FUN = num_in_km))),
y = 1000, hjust = -0.1) +
theme(panel.background = element_rect(fill = '#2b3e50'),
plot.background = element_rect(fill = '#2b3e50'),
strip.background = element_blank(),
axis.line.y = element_line(color = 'white'),
axis.line.x = element_blank(),
axis.ticks.x = element_blank(),
axis.text = element_text(color = 'white'),
axis.title = element_text(color = 'white', face = 'bold'),
panel.grid.major.x = element_blank(),
title = element_text(color = 'white', face = 'bold'),
legend.position = 'none',
legend.title = element_blank(),
legend.text = element_text(color = 'white', face = 'bold'),
legend.background = element_rect(fill = '#2b3e50'))
png(filename = sprintf('case_prediction_curves%s.png', strftime(Sys.date(), format = '%m_%d_%Y')), width = 1200, height = 800, res = 100)
print(g)
dev.off()
packages <- append(unlist(cfg['packages']), 'broom', 'ggrepel')
library(yaml)
cfg <- yaml::read_yaml('cfg.yml')
packages <- append(unlist(cfg['packages']), 'broom', 'ggrepel')
for (p in packages) library(p, character.only = TRUE, quietly = TRUE, verbose = FALSE)
source('load_data.R')
model_dat <- country_grouped %>%
mutate(Confirmed2 = Confirmed^2) %>%
as.data.table()
model_dat$Country.Region <- replace(model_dat$Country.Region, model_dat$Country.Region == 'Korea, South', 'South Korea')
model_dat$Country.Region <- replace(model_dat$Country.Region, model_dat$Country.Region == 'United Kingdom', 'UK')
model_dat$Country.Region <- replace(model_dat$Country.Region, model_dat$Country.Region == 'Iran (Islamic Republic of)', 'Iran')
models <- model_dat %>%
group_by(Country.Region) %>%
do(Country.Fit = lm(formula = Confirmed_rate ~ Confirmed + I(Confirmed^2), data = .))
model.coeffs = tidy(models, Country.Fit)
signif_models <- (model.coeffs %>%
group_by(Country.Region) %>%
summarise(avgP = median(p.value)) %>%
filter(avgP <= 1e-6) %>%
select(Country.Region) %>%
as.data.frame())$Country.Region
if (!('South Korea' %in% signif_models)) signif_models <- append(signif_models, 'South Korea')
signif_data <- model_dat %>%
filter(Country.Region %in% signif_models)
country_predictions <- tibble()
for (c in signif_models) {
subset <- model_dat %>%
filter(Country.Region == c)
country.mod <- lm(formula = Confirmed_rate ~ Confirmed + I(Confirmed^2), data = subset)
assign(paste0('model.', c), country.mod)
subset$Predicted <- predict(object = country.mod, newdata = subset)
country_predictions <- country_predictions %>%
bind_rows(subset)
}
get_x_intercepts <- function(coefs) {
a <- coefs['I(Confirmed^2)']
b <- coefs['Confirmed']
c <- coefs['(Intercept)']
x = c((-b + sqrt(b^2 - 4 * a * c))/(2 * a),
(-b - sqrt(b^2 - 4 * a * c))/(2 * a))
return(x)
}
num_in_km <- function(num) {
if (num > 1000000) out <- paste(round(num/1000000), 'M') else if (num > 1000) out <- paste(round(num/1000), 'K') else out <- round(num)
return(out)
}
# Country Data ------------------------------------------------------------
countries <- c()
predict_starts <- c()
predict_ends <- c()
prediction_curves <- data.frame()
for (country in unique(country_predictions$Country.Region)) {
coefs <- coef(get(paste0('model.', country)))
tryCatch({
intercepts <- get_x_intercepts(coefs)
}, warning = function(w) {
cat(c)
intercepts <- get_x_intercepts(coefs)
})
countries <- append(countries, country)
predict_starts <- append(predict_starts, intercepts[1])
predict_ends <- append(predict_ends, intercepts[2])
prediction_x <- seq(intercepts[1], intercepts[2], length.out = 100)
prediction_y <- coefs['(Intercept)'] + coefs['Confirmed'] * prediction_x + coefs['I(Confirmed^2)'] * (prediction_x^2)
curve_data <- data.frame(Country.Region = country, Confirmed = prediction_x, Confirmed_rate = prediction_y)
prediction_curves %>%
bind_rows(curve_data) -> prediction_curves
}
predicted_totals <- data.frame(Country.Region = countries,
Predicted.Start = predict_starts,
Predicted.End = predict_ends)
# Plot the data
g <- ggplot(data = prediction_curves,
mapping = aes(x = Confirmed, y = Confirmed_rate, colour = Country.Region, fill = Country.Region)) +
labs(title = 'Case Trajectories',
subtitle = 'With Fitted Parabolic Models',
x = 'Total Cases',
y = 'Daily New Case Rate') +
geom_line() +
geom_point(data = country_predictions) +
geom_text_repel(data = predicted_totals, mapping = aes(x = predict_ends,
label = paste(Country.Region, sapply(predict_ends, FUN = num_in_km))),
y = 1000, hjust = -0.1) +
theme(panel.background = element_rect(fill = '#2b3e50'),
plot.background = element_rect(fill = '#2b3e50'),
strip.background = element_blank(),
axis.line.y = element_line(color = 'white'),
axis.line.x = element_blank(),
axis.ticks.x = element_blank(),
axis.text = element_text(color = 'white'),
axis.title = element_text(color = 'white', face = 'bold'),
panel.grid.major.x = element_blank(),
title = element_text(color = 'white', face = 'bold'),
legend.position = 'none',
legend.title = element_blank(),
legend.text = element_text(color = 'white', face = 'bold'),
legend.background = element_rect(fill = '#2b3e50'))
png(filename = sprintf('case_prediction_curves%s.png', strftime(Sys.date(), format = '%m_%d_%Y')), width = 1200, height = 800, res = 100)
print(g)
dev.off()
save(model.coeffs, country_predictions, predicted_totals, prediction_curves, 'data/parabolic_models_4_4_2020.RData')
save(model.coeffs, country_predictions, predicted_totals, prediction_curves, file = 'data/parabolic_models_4_4_2020.RData')
library(ggreple)
library(ggrepel)
# Plot the data
g <- ggplot(data = prediction_curves,
mapping = aes(x = Confirmed, y = Confirmed_rate, colour = Country.Region, fill = Country.Region)) +
labs(title = 'Case Trajectories',
subtitle = 'With Fitted Parabolic Models',
x = 'Total Cases',
y = 'Daily New Case Rate') +
geom_line() +
geom_point(data = country_predictions) +
geom_text_repel(data = predicted_totals, mapping = aes(x = predict_ends,
label = paste(Country.Region, sapply(predict_ends, FUN = num_in_km))),
y = 1000, hjust = -0.1) +
theme(panel.background = element_rect(fill = '#2b3e50'),
plot.background = element_rect(fill = '#2b3e50'),
strip.background = element_blank(),
axis.line.y = element_line(color = 'white'),
axis.line.x = element_blank(),
axis.ticks.x = element_blank(),
axis.text = element_text(color = 'white'),
axis.title = element_text(color = 'white', face = 'bold'),
panel.grid.major.x = element_blank(),
title = element_text(color = 'white', face = 'bold'),
legend.position = 'none',
legend.title = element_blank(),
legend.text = element_text(color = 'white', face = 'bold'),
legend.background = element_rect(fill = '#2b3e50'))
png(filename = sprintf('case_prediction_curves%s.png', strftime(Sys.date(), format = '%m_%d_%Y')), width = 1200, height = 800, res = 100)
print(g)
dev.off()
png(filename = sprintf('case_prediction_curves%s.png', strftime(Sys.time(), format = '%m_%d_%Y')), width = 1200, height = 800, res = 100)
print(g)
dev.off()
prediced_totals
predicted_totals
files <- list.files('data', pattern = '.RData')
files_as_dates <- as.Date(gsub('.Rdata', '', files), format = '%m-%d-%Y')
files_as_dates
files <- list.files('data', pattern = '.RData')
files_as_dates <- as.Date(gsub('.Rdata', '', files), format = '%m-%d-%Y')
assign('max_data_date', max(files_as_dates, na.rm = TRUE), envir = .GlobalEnv)
assign('connected', TRUE, envir = .GlobalEnv)
load(file.path('data', files[which(files_as_dates == max(files_as_dates))]))
files[which(files_as_dates == max(files_as_dates))]
load(file.path('data', files[which(files_as_dates == max(files_as_dates, na.rm = TRUE))]))
max(files_as_dates, na.rm = TRUE)
shiny::runApp()
shiny::runApp()
